#!/usr/bin/python
# daygen.py - generator of aoc days
# daygen.py path name
import sys
import os
from datetime import date

# Check args
total = len(sys.argv)
if total < 3:
    print ("Missing arguments")
    print ("Use: daygen.py PATH NAME")
    print ("Inside PATH create a directory named NAME.")
    exit(1)

PATH = sys.argv[1]
NAME = sys.argv[2]

if (PATH[-1] == '/'):
    FULLPATH = PATH + NAME
else:
    FULLPATH = PATH + "/" + NAME


response = input("Create %s ? (Y)\n>" % FULLPATH)
if (len(response) > 0 and response[0] != 'y' and response[0] != 'Y'):
    print("terminate")
    exit(1)

print("continue")

try:
    print("Create dir")
    os.mkdir(FULLPATH)
except FileNotFoundError:
    print("Error in path")
    exit(1)
except FileExistsError:
    print("Already exists, continue")

print ("Create: " + FULLPATH + "/" + NAME + ".cpp")
filecpp = open(FULLPATH + "/" + NAME + ".cpp", "w")
today = date.today()

filecpp.write("/**\n")
filecpp.write(" * @file    %s.cpp\n" % NAME)
filecpp.write(" * @brief   \n")
filecpp.write(" * @project advent of code\n")
filecpp.write(" * \n")
filecpp.write(" * @author  Niccol√≤ Pieretti\n")
filecpp.write(" * @date    %s\n" % today.strftime("%d %b %Y"))
filecpp.write(" * \n")
filecpp.write(" ****************************************************************************-\n")
filecpp.write(" *                                              \n")
filecpp.write(" *             _  _   o   __  __   __    _  o   _   ,_    _  \n")
filecpp.write(" *            / |/ |  |  /   /    /  \_|/ \_|  |/  /  |  |/  \n")
filecpp.write(" *              |  |_/|_/\__/\___/\__/ |__/ |_/|__/   |_/|__/\n")
filecpp.write(" *                                    /|                     \n")
filecpp.write(" *                                    \|     \n")
filecpp.write(" ****************************************************************************/\n")
filecpp.write("\n")
filecpp.write("#include <fstream>\n")
filecpp.write("#include <iostream>\n")
filecpp.write("#include <string>\n")
filecpp.write("#include <functional>\n")
filecpp.write("\n")
filecpp.write("namespace %s {\n" % NAME)
filecpp.write("\n")
filecpp.write("template<class T, class R>\n")
filecpp.write("R parse(std::string inputFilename, char delimiter, \n")
filecpp.write("        std::function <T(std::string)> convert, \n")
filecpp.write("        std::function <R(T, R)> foldl, R accumulatorValue) {\n")
filecpp.write("    \n")
filecpp.write("    std::ifstream source;\n")
filecpp.write("    source.open(inputFilename);\n")
filecpp.write("    R accumulator = accumulatorValue;\n")
filecpp.write("    std::string part;\n")
filecpp.write("    while (std::getline(source, part, delimiter)) {\n")
filecpp.write("        accumulator = foldl(convert(part), accumulator);\n")
filecpp.write("    }\n")
filecpp.write("    return accumulator ;\n")
filecpp.write("}\n")
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("template<class T, class R>\n")
filecpp.write("void read(std::string inputFilename, char delimiter, \n")
filecpp.write("        std::function <T(std::string)> convert, \n")
filecpp.write("        std::function <void(T, R)> insert, R structure) {\n")
filecpp.write("    \n")
filecpp.write("    std::ifstream source;\n")
filecpp.write("    source.open(inputFilename);\n")
filecpp.write("    std::string part;\n")
filecpp.write("    while (std::getline(source, part, delimiter)) {\n")
filecpp.write("        insert(convert(part), structure);\n")
filecpp.write("    }\n")
filecpp.write("}\n")
filecpp.write("\n")
filecpp.write("uint64_t process1(std::string file);\n")
filecpp.write("uint64_t process2(std::string file);\n")
filecpp.write("\n")
filecpp.write("uint64_t findSolution();\n")
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("// ===== ===== ===== Lambdas ===== ===== ===== \n")
filecpp.write("\n")
filecpp.write("auto map = [](std::string part) -> uint64_t { \n")
filecpp.write("    uint64_t seatId = 0;\n")
filecpp.write("    return seatId;\n")
filecpp.write("};\n")
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("auto foldl = [](uint64_t seatId, uint64_t maxId) -> uint64_t { \n")
filecpp.write("    return maxId >= seatId ? maxId : seatId; \n")
filecpp.write("};\n")
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("auto order_insert = [](uint64_t value, std::list<uint64_t> * list) {\n")
filecpp.write("    auto it = std::lower_bound(list->begin(), list->end(), value);\n")
filecpp.write("    list->insert(it, value);\n")
filecpp.write("};\n")
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("} // namespace %s\n" % NAME)
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("// ===== ===== ===== Main ===== ===== ===== \n")
filecpp.write("int main (int argc, char *argv[]) {\n")
filecpp.write("    if (argc < 2) {\n")
filecpp.write("        std::cout << \"No input file\" << std::endl;\n")
filecpp.write("        return 1;\n")
filecpp.write("    }\n")
filecpp.write("	std::string inputFilename(argv[1]);\n")
filecpp.write("\n")
filecpp.write("    // Part 1\n")
filecpp.write("    std::cout << \"Part1\" << std::endl;\n")
filecpp.write("    std::cout << %s::process1(inputFilename) << std::endl;\n" % NAME)
filecpp.write("    \n")
filecpp.write("    // Part 2\n")
filecpp.write("    std::cout << \"Part2\" << std::endl;\n")
filecpp.write("    std::cout << %s::process2(inputFilename) << std::endl;\n" % NAME)
filecpp.write("\n")
filecpp.write("	return 0;\n")
filecpp.write("}\n")
filecpp.write("\n")
filecpp.write("\n")
filecpp.write("// ===== ===== ===== Implementations ===== ===== ===== \n")
filecpp.write("\n")
filecpp.write("uint64_t %s::process1(std::string file) {\n" % NAME)
filecpp.write("    uint64_t result = %s::parse<uint64_t, uint64_t>(file, '\\n', \n" % NAME)
filecpp.write("                            %s::map, \n" % NAME)
filecpp.write("                            %s::foldl, 0);\n" % NAME)
filecpp.write("    return result;\n")
filecpp.write("}\n")
filecpp.write("\n")
filecpp.write("uint64_t %s::process2(std::string file) {\n" % NAME)
filecpp.write("    std::list<uint64_t> list;\n")
filecpp.write("    %s::read<uint64_t, std::list<uint64_t>*>(file, '\\n', \n" % NAME)
filecpp.write("                %s::map, \n" % NAME)
filecpp.write("                %s::order_insert, &list);\n" % NAME)
filecpp.write("\n")
filecpp.write("    uint64_t result = %s::findSolution(list);\n" % NAME)
filecpp.write("    return result;\n")
filecpp.write("}\n")
filecpp.write("\n")
filecpp.write("uint64_t %s::findSolution() {\n" % NAME)
filecpp.write("    return 0;\n")
filecpp.write("}\n")


print ("Create: " + FULLPATH + "/CMakeLists.txt")

filecmake = open(FULLPATH + "/CMakeLists.txt", "w")

filecmake.write("# ===== ===== ===== Setups ===== ===== ===== \n")
filecmake.write("cmake_minimum_required(VERSION 3.11)\n")
filecmake.write("\n")
filecmake.write("# Project name and a few useful settings. Other commands can pick up the results\n")
filecmake.write("project(aoc_%s\n" % NAME)
filecmake.write("    VERSION 1.0\n")
filecmake.write("    DESCRIPTION \"Advent of code: %s\"\n" % NAME)
filecmake.write("    )\n")
filecmake.write("\n")
filecmake.write("    # Optionally set things like CMAKE_CXX_STANDARD, CMAKE_POSITION_INDEPENDENT_CODE here\n")
filecmake.write("    set(CMAKE_CXX_STANDARD 11)\n")
filecmake.write("    set(CMAKE_CXX_STANDARD_REQUIRED ON)\n")
filecmake.write("    # Let's ensure -std=c++xx instead of -std=g++xx\n")
filecmake.write("    set(CMAKE_CXX_EXTENSIONS OFF)\n")
filecmake.write("    # Enable clang-tidy\n")
filecmake.write("#    set(CMAKE_CXX_CLANG_TIDY \"clang-tidy;-header-filter=include;-checks=*,-llvmlibc*\")\n")
filecmake.write("\n")
filecmake.write("# https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags\n")
filecmake.write("    add_compile_options(-Wall -Wextra -Wno-unused-parameter \n")
filecmake.write("        -pedantic \n")
filecmake.write("        -Wshadow -Wdouble-promotion\n")
filecmake.write("        -Wformat=2 -Wformat-truncation\n")
filecmake.write("        -ffunction-sections -fdata-sections\n")
filecmake.write("        $<$<CONFIG:RELEASE>:-Werror> \n")
filecmake.write("        $<$<NOT:$<CONFIG:DEBUG>>:-O2> \n")
filecmake.write("        -g3 -fPIC)\n")
filecmake.write("\n")
filecmake.write("    set (CMAKE_RUNTIME_OUTPUT_DIRECTORY bin)\n")
filecmake.write("    \n")
filecmake.write("    # Let's nicely support folders in IDE's\n")
filecmake.write("    set_property(GLOBAL PROPERTY USE_FOLDERS ON)\n")
filecmake.write("\n")
filecmake.write("\n")
filecmake.write("# ===== ===== ===== Code ===== ===== ===== \n")
filecmake.write("\n")
filecmake.write("add_executable (%s %s.cpp )\n" % (NAME, NAME))
filecmake.write("target_compile_features(%s PRIVATE cxx_std_11)" % NAME)

print ("Create: " + FULLPATH + "/input.txt")

filecmake = open(FULLPATH + "/input.txt", "w")

print("done")